#!/usr/bin/perl
# -*- mode: perl; buffer-file-coding-system: utf-8 -*-
# test_links.pl                   falk@gurumusch
#                    25 MÃ¤r 2020

use warnings;
use strict;
use English;

use Data::Dumper;
use Carp;
use Carp::Assert;

use Pod::Usage;
use Getopt::Long;

use utf8;

=head1 NAME

test_links.pl

=head1 USAGE

   perl  test_links.pl --json=recipes.json index.html

=head1 DESCRIPTION

Tests whether links given in json file are the same as those produced by gourmet html export (in index.html).

For example, the script tests given the json file (given as option)
below, whether there is an I<a> element with a reference to 'Potato
and Leek Frittata Recipe1.htm' in the html table given in the html
file given as argument.

=head1 REQUIRED ARGUMENTS

File containing html table with recipes generated by gourmet html
export.  

A table data or I<td> element in the table is expected to contain a reference or
link to an C<html> file containing the recipe description. It should look somewhat like this:

   <td><a href="Potato and Leek Frittata Recipe1.htm">Potato and Leek Frittata Recipe</a></td>

=head1 OPTIONS

=over

=item json, required

A file containing the json structure with the recipes. The format is as follows

 [
  {
   "id":"1",
   "title":"<a href='Potato and Leek Frittata Recipe1.htm'>Potato and Leek Frittata Recipe</a>",
   ...
   },
   ...
  ]

The item of interest is I<title>

=cut


my %opts = (
	    'json' => '',
	   );

my @optkeys = (
	       'json=s',
	      );

unless (GetOptions (\%opts, @optkeys)) { pod2usage(2); };
unless (@ARGV) { pod2usage(2) }; 

my @required = qw(json);


use List::MoreUtils qw(all);


unless (all { $opts{$_} } @required) { pod2usage(2) };


use List::MoreUtils qw(all firstidx);
unless (all { $opts{$_} }  @required) { pod2usage(2) } ;

binmode(STDERR, ':encoding(UTF-8)');
binmode(STDOUT, ':encoding(UTF-8)');

use JSON;
use File::Slurp;

my $json_text = read_file($opts{json});

my $json_pl = decode_json $json_text;
my $nbr_js_entries = @{ $json_pl };
print STDERR "Number of json entries: $nbr_js_entries\n";

my $json_links;

foreach my $entry (@{ $json_pl }) {
  my $id = $entry->{'id'};
  my $link = $entry->{'title'};
  unless ($link) {
    print STDERR Dumper($entry);
  }
  $link =~ s{<a href='}{};
  $link =~ s{'>.*$}{}xmsg;
  $json_links->{$id} = $link;
}

my $nbr_links = keys %{ $json_links };
print STDERR "Number of json links: $nbr_links\n";

#print STDERR Dumper($json_links);

my $link_hrefs;

use HTML::Parser ();

open my $fh, '<:encoding(utf-8)', $ARGV[0] or croak "Couldn't open $ARGV[0] for input:$!\n";

my $p = HTML::Parser->new(api_version => 3,
     start_h => [\&a_start_handler, "self,tagname,attr"],
     report_tags => [qw(a img)],
    );
$p->parse_file($fh);
 
sub a_start_handler
{
    my($self, $tag, $attr) = @_;
    return unless $tag eq "a";
    return unless exists $attr->{href};
    # print "A $attr->{href}\n";
    my $link = $attr->{href};
    my $id = 'no_id';
    if ($link =~ m{(\d+)\.htm}) {
      $id = $1;
      $link_hrefs->{$id} = $link;
    };
	
    $self->handler(text  => [], '@{dtext}' );
    $self->handler(start => \&img_handler);
    $self->handler(end   => \&a_end_handler, "self,tagname");
}
 
sub img_handler
{
    my($self, $tag, $attr) = @_;
    return unless $tag eq "img";
    push(@{$self->handler("text")}, $attr->{alt} || "[IMG]");
}
 
sub a_end_handler
{
    my($self, $tag) = @_;
    my $text = join("", @{$self->handler("text")});
    # $text =~ s/^\s+//;
    # $text =~ s/\s+$//;
    # $text =~ s/\s+/ /g;
    # print "T $text\n";
 
    $self->handler("text", undef);
    $self->handler("start", \&a_start_handler);
    $self->handler("end", undef);
}

$nbr_links = keys %{ $link_hrefs };
print STDERR "Number of table links: $nbr_links \n";

#print STDERR Dumper($link_hrefs);

my %counts;
foreach my $link (keys %{ $json_links }, keys %{ $link_hrefs }) {
  $counts{$link}++;
}

my @intersection;
my @difference;
foreach my $element (keys %counts) {
    push @{ $counts{$element} > 1 ? \@intersection : \@difference }, $element;
}

my %diff;

my @diff_json;
my @diff_html;
foreach my $element (@difference) {
  if ($json_links->{$element}) {
    push @diff_json, $element;
  } elsif ($link_hrefs->{$element}) {
    push @diff_html, $element;
  }
}

print STDERR "In json, not in html: $#diff_json\n\n";
if (@diff_json) {
  print STDERR join(', ', sort { $a <=> $b } @diff_json), "\n";
}

print STDERR "In html, not in json: $#diff_html\n\n";

if (@diff_html) {
  print STDERR join(', ', sort { $a <=> $b } @diff_html), "\n";
}
foreach my $id (sort { $a <=> $b } @diff_html) {
  print "$id: $link_hrefs->{$id}\n";
}  



1;





__END__

=head1 EXIT STATUS

=head1 CONFIGURATION

=head1 DEPENDENCIES

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

created by template.el.

It looks like the author of this script was negligent
enough to leave the stub unedited.


=head1 AUTHOR

Ingrid Falk, E<lt>E<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2020 by Ingrid Falk

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.2 or,
at your option, any later version of Perl 5 you may have available.

=head1 BUGS

None reported... yet.

=cut
